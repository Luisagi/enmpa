% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calibration_glm.R
\name{calibration_glm}
\alias{calibration_glm}
\title{GLM calibration with presence-absence data}
\usage{
calibration_glm(data, dependent, independent, weights = NULL,
                response_type = "l", all_combinations = TRUE,
                minvar = 1, maxvar = NULL, user_formulas = NULL,
                cv_kfolds = 5, partition_index = NULL, seed = 1,
                n_threshold = 100, selection_criterion = "TSS",
                exclude_bimodal = FALSE, tolerance = 0.01,
                out_dir = NULL, parallel = FALSE,
                n_cores = NULL, verbose = TRUE)
}
\arguments{
\item{data}{data.frame or matrix of independent variables.}

\item{dependent}{(character) name of dependent variable.}

\item{independent}{(character) vector of name(s) of independent variable(s).}

\item{weights}{(numeric) a vector with the weights for observations.}

\item{response_type}{(character) a character string that must contain "l",
"p", "q" or a combination of them. l = lineal, q = quadratic,
p = interaction between two variables. Default = "l".}

\item{all_combinations}{(logical) whether to produce all combinations of
formulas according to \code{response_type}, default = TRUE. FALSE returns only
the most complex formula defined in \code{response_type}.}

\item{minvar}{(numeric) minimum number of features.}

\item{maxvar}{(numeric) maximum number of features.}

\item{user_formulas}{a vector of character with the set of formulas to test.
Default = NULL.}

\item{cv_kfolds}{(numeric) number of folds to use for k-fold
cross-validation exercises. Default = 5. Ignored if \code{partition_index}
is defined.}

\item{partition_index}{list of indices for cross-validation in k-fold. It can
be calculated with enmpa::kfold_partition. Default = NULL.}

\item{seed}{(numeric) a seed for k-fold partitioning.}

\item{n_threshold}{(logical) number of thresholds to use to produce
evaluation metrics. Default = 100,}

\item{selection_criterion}{(character) criterion used to select best models,
options are "TSS" and "ESS". Default = "TSS".}

\item{exclude_bimodal}{(logical) whether to exclude from selected models those
with one or more variable presenting concave responses. Default = FALSE.}

\item{tolerance}{(numeric) value to modify the metric used for model filtering
for model selection if no models meet initial the consideration.
Default = 0.01}

\item{out_dir}{(character) output directory name to save the main calibration
table results. Default = \code{NULL}.}

\item{parallel}{(logical) whether to run on parallel or sequential.
Default = FALSE.}

\item{n_cores}{(numeric) number of cores to use. Default = number of free
processors - 1.}

\item{verbose}{(logical) whether to print messages and show progress bar.
Default = TRUE}
}
\value{
A list containing: selected models, a summary of statistics for all models,
results obtained in cross-validation for all models, original data used, and
weights.
}
\description{
Wrapper function for facilitating model calibration and selection using
presence-absence data and GLMs.
}
\details{
Model evaluation is done considering the ability to predict presences and
absences. Model selection consists of three steps: 1) a first filter to keep
the models with ROC AUC >= 0.5 (statistically significant models), 2) a
second filter to maintain only models that meet the \code{selection_criterion}
("TSS": TSS >= 0.4; or "ESS": maximum Accuracy - \code{tolerance}), and 3) from
those, pick the ones with delta AIC <= 2.
}
\examples{
library(enmpa)

# Load species occurrences and environmental data.
enm_data <- read.csv(system.file("extdata", "pa_data.csv", package = "enmpa"))
head(enm_data)

# Calibration using linear (l), quadratic (q), products(p) responses.
cal_res <- calibration_glm(data = enm_data,
                           dependent = "Sp",
                           independent = c("bio_1", "bio_12"),
                           response_type = "lpq",
                           selection_criterion = "TSS",
                           cv_kfolds = 3,
                           exclude_bimodal = TRUE,
                           verbose = FALSE)

head(cal_res$calibration_results)
head(cal_res$summary)
head(cal_res$selected)
head(cal_res$data)

}
